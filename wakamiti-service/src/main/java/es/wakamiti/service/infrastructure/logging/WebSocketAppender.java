/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */
package es.wakamiti.service.infrastructure.logging;


import ch.qos.logback.classic.spi.ILoggingEvent;
import ch.qos.logback.core.AppenderBase;
import ch.qos.logback.core.Layout;
import es.wakamiti.service.domain.spi.LogEventPublisher;


/**
 * Custom Log4j2 appender that streams log messages to WebSocket clients in real-time.
 * 
 * <p>This appender extends AbstractAppender to integrate with Log4j2's logging framework
 * and provides real-time log streaming capabilities via WebSocket connections. When a log
 * event occurs, it formats the message, stores it in a buffer for new connections, and
 * broadcasts it to all active WebSocket sessions.</p>
 * 
 * <p>Key features:</p>
 * <ul>
 *   <li>Real-time log streaming to WebSocket clients</li>
 *   <li>Message buffering for connection history replay</li>
 *   <li>Integration with Log4j2 plugin system</li>
 *   <li>Thread-safe message broadcasting</li>
 * </ul>
 * 
 * <p>Usage in log4j2.xml:</p>
 * <pre>{@code
 * <WebSocketAppender name="WS">
 *   <PatternLayout pattern="%msg%n"/>
 * </WebSocketAppender>
 * }</pre>
 */
public class WebSocketAppender extends AppenderBase<ILoggingEvent> {

    private LogEventPublisher<?> publisher;
    private Layout<ILoggingEvent> layout;

    public WebSocketAppender() {
        super();
    }

    public void setPublisher(
            LogEventPublisher<?> publisher
    ) {
        this.publisher = publisher;
    }

    public void setLayout(
            Layout<ILoggingEvent> layout
    ) {
        this.layout = layout;
    }

    @Override
    protected void append(
            ILoggingEvent event
    ) {
        // Avoids processing logs generated by the WebSocket system itself to prevent loops.
        if (event.getLoggerName().contains(this.getClass().getPackageName())) {
            return;
        }

        if (publisher != null && layout != null) {
            publisher.publish(layout.doLayout(event));
        }
    }
}